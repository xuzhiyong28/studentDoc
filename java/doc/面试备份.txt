面试官你好，我叫XX，毕业于XXX，从事JAVA相关开发5年多。目前就职于XXX技数据中台部负责流量计费系统的开发和系统的优化。 目前比较熟悉的技术栈包括JAVA相关知识,Kafka中间件,Spring,SpringMVC,SpringBoot,Redis,MyBatis,MySQL,当当ShardingJdbc分库分表组件,ZK,MySQL数据库
任职期间主要做的工作包括
	0.系统的开发优化和维护
	1.改造了API端Redis缓存机制使性能有了很大提升，	2.独立设计并开发了入库自动化平台，采用配置的方式实现了不同类型数据的正常入库，采用分库分表实现了每天百万数据的获取和存储。



=================================================================

redis如何做缓存
原始方案 : Jedis + 哨兵模式(一主两从) + 采用字符串结构存储(key=客户,value=所有域名对象)
问题 
	1. 由于业务的发展，逐渐出现大客户有几万个域名的情况，导致了接口耗时出现了突刺。原因是获取大KEY的耗时阻塞了Redis其他请求。
	2. Jedis + 哨兵模式  在经过研究代码发现，底层Jedis是通过连接哨兵获取到master然后连接到master，并订阅了switch频道，这个频道是在master宕机时，Redis的哨兵会执行故障转移，并将转移的信息发送到这个频道上，所以客户端订阅了这个频道后能感知master宕机，从而在哨兵执行故障转移后连接新的master，保证程序的正常运行。
		其中这种模式有两个问题 ：
			1. Jedis所谓连接哨兵，也只是将请求发到master，Jedis内部没做读写分离。所以是master承担了所有的请求，而slave只是做一个备份，资源比较浪费。
			2. 由于业务上逐渐有大客户存了大量域名，导致内存开始不够用。
改造 ：
	1. 采用集群模式，一台机器两个实例，两两互相主备，例如实例A在第一台机器，他的备份在第二台
	2. 对存储方式进行改造，结合我们业务上的需求
		1.将存储方式改成哈希的方式，key=客户，filed=域名1，value1=域名其他信息
		2.大客户采用分段的方式，例如有个大客户叫网易，有5万多个域名，那我分成16个key,例如网易0到15这样子。然后域名通过 h ^ (h >>> 16)的方式看存储在哪个桶里面。（数据库对应的也存了这个域名对应的桶位，方便过期时通过桶信息获取到这个桶上的域名并存入缓存，这样不用所有的桶都做更新）
改造后的效果:
		1.上面的改造解决了大部分请求是通过直接查询域名的方式，例如我查网易其中一个域名，先通过散列算一下他在哪个分段KEY上，然后在对应的分段KEY上获取到他对应的信息。
		2.充分利用了三台机器的内存。

如果被问到，如何保持数据库和缓存一致性时
1.可以答项目上对缓存的实时性要求不高，目前我是采用从缓存中读取，如果没有就是查数据库的方式，如果没有就从数据库中读取并添加到缓存中去。其中采用双检查分布式锁的方式来做这个操作，防止大量请求打到数据库中去。这里可以不使用分布式锁，直接使用JAVA锁就行，因为我们API部署的机器并不多，只有6台，用JAVA锁的粒度更细，性能更好，最差最差的情况也就6台同时去访问数据库。但是如果用了分布式锁，出现网络问题的话就可能导致请求都被卡住。
2.因为对实时性不高，所以数据库更改并没有通知Redis，如果要保持一致性的话，可以采用延迟双删的策略，或者使用阿里巴巴canal，当binlog发生变化时修改Redis。


====================================================================
入库平台化设计
背景 : 例如现在有一个客户A的域名购买了公司的加速服务，例如直播加速，那么加速机器上会记录每5分钟域名加速的量，我们需要对这些数据获取并存储，方便后面计算。大概是这样一个背景。 计费流量数据需要从上游几个组件获取，数据类型多，但是结构都较为相似。原来没做入库平台化之前，都是开发人员接到需求后自己开发，且在功能上没有比较统一的数据修复，数据重拉，漏点监控，数据比对功能，且采用单表单库存储，无法新业务数据量大的存储。
难点 :	1.实现自动化配置
		2.数据量大，有些类型每天有30多万数据量
		3.要求时效性，例如前5分钟机器记录了加速的量，随后2分钟内要求页面上能展示出来
		4.运维上能实现数据的漏点修复，机房之间数据对比，数据修复重拉

设计 : 
	1.数据量大的问题
		采用分库分表的方式，因为是每个域名每天每5分钟的量，所以设计表结构上字段包括:域名，日期，1到288列，每一列代表每5分钟加速的数据量。 分库分表采用: 年份 + 日期对4去取模分库，按月分表的方式。例如2021年1月21号。那么我这个日期的数据会被分到2021年01库，1月份这张表。这样分的目的是让数据量平分到每台机器上去。


遇到的问题 ：
	1.数据要求准确性和时效性，业务迭代快，三天两头的就要求一个新类型的入库。当一个新加速类型需要入库，需要为这个新类型配置sharding的分片配置，所以要重启Tomcat，这样会造成部分点的数据丢失。为了解决这个问题，使用了Zookeeper的Watch机制。
	2.Tomcat启动慢
	3.ShardingJDBC没有维护分库和分表的关系，导致查了一定没有我要的数据库的库和表

======================================================
	
	
如何做JVM调优
一般做JVM调优我是从下面几个步骤去解决
1.发现并定位问题 jstat命令 --（观察当前minnorGC和mainGC的频率和时间） + GC日志分析CMS过程(初始标记-并发标记-并发预处理-重新标记-并发清理) 
3.解决问题  调整堆大小 + 设置优化参数（例如晋升年龄阈值，大对象阈值，CMS老年代占用多少空间时启用并发收集，设置并发预处理的时间，CMS碎片整理）
1.例如观察到minorGC频率高，可以结合GC日志看看，每次minnorGC前后内存的对比，如果前后差距大，证明对象朝生夕死，可以适当添加新生代的内存
2.注意GC日志是否有出现并发模式失败和晋升失败的关键字，

jstack
死锁，Deadlock（重点关注）
执行中，Runnable
等待资源，Waiting on condition（重点关注）
等待获取监视器，Waiting on monitor entry（重点关注）
暂停，Suspended
对象等待中，Object.wait() 或 TIMED_WAITING
阻塞，Blocked（重点关注）
停止，Parked
===========================================================


================================================================

Innodb的单位一个16K的页，通过页作为节点组成一棵多路平衡树，也就是B+树，树的叶子节点存放的是按照索引排序的数据。如果是局促索引，这些数据就是每一列的数据，如果是非局促索引，存放的是非局促索引，存放的就是索引+主键的形式。非叶子节点存放的是索引页,存放的是索引和页号的一个关系。当要查询一条数据时，通过从根节点开始一层一层定位到叶子节点中索引对应的页，然后就可以快速找到对应的数据。

=================================================================

RDB的原理是fork一个子进程将内存中的数据持久化到磁盘并覆盖原来的dump文件。
RDB的优点是适合备份,使用RDB恢复数据速度快，缺点是如果要尽可能避免服务器故障后丢失的数据少，RDB就不太适合。
AOF的原理是将每个写命令追加到AOF日志文件里面去，他的优点是在服务器故障时能尽可能保证数据不丢失，缺点是恢复数据的速度慢，文件大

===============================================
AOP原理描述
AOP他是一种编程思想，面向切面编程。他的主要作用是在开发者不修改源代码的情况下去为业务增加一些通用功能。主要分成静态AOP和动态AOP。静态AOP采用是在编译期间通过字节码植入的方式，动态AOP也就是SpringAOP的方式，主要是通过动态代理和cglib代理实现的。
当我们创建一个Bean时，Bean经过生命周期从实例化，属性赋值，初始化后会调用Bean的后置处理器(这里可以延伸说以下Bean后置处理器是怎么加入进来的)。后置处理器方法中会获取所有通知advisor，并判断当前Bean是否符合切入点表达式。如果符合就为这个Bean创建动态代理。


================================================
当一个方法使用了@Transactional注解，在运行时，Spring为该Bean创建一个代理对象，并且在调用该方法的时候进行使用TransactionInterceptor拦截，在方法执行之前会开启一个事务，然后执行方法的逻辑。方法执行成功，则提交事务。如果执行方法中出现异常，则回滚事务。
